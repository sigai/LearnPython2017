#面向对象编程
面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。

所谓编程范式（programming paradigm），指的是计算机编程的基本风格或典范模式。借用哲学的术语，如果说每个编程者都在创造虚拟世界，那么编程范式就是他们置身其中自觉不自觉采用的世界观和方法论。我们知道，编程是为了解决问题，而解决问题可以有多种视角和思路，其中普适且行之有效的模式被归结为范式。

对象的英文是object(物体)，就是在编程中，将数据和行为进行合理的结合，模仿现实世界的物体的属性和行为，方便管理。

面向对象的特性：封装、继承、多态
object oriented progamming

##编程范式
编程是 程序 员 用特定的语法+数据结构+算法组成的代码来告诉计算机如何执行任务的过程 ， 一个程序是程序员为了得到一个任务结果而编写的一组指令的集合，正所谓条条大路通罗马，实现一个任务的方式有很多种不同的方式， 对这些不同的编程方式的特点进行归纳总结得出来的编程方式类别，即为编程范式。 不同的编程范式本质上代表对各种类型的任务采取的不同的解决问题的思路， 大多数语言只支持一种编程范式，当然也有些语言可以同时支持多种编程范式。 两种最重要的编程范式分别是面向过程编程和面向对象编程。

###面向过程编程(Procedural Programming)
Procedural programming uses a list of instructions to tell the computer what to do step-by-step.
面向过程编程使用一系列的指令告诉计算机一步一步的执行.
面向过程编程依赖 - 你猜到了- procedures，一个procedure包含一组要被进行计算的步骤， 面向过程又被称为top-down languages， 就是程序从上到下一步步执行，一步步从上到下，从头到尾的解决问题 。基本设计思路就是程序一开始是要着手解决一个大的问题，然后把一个大问题分解成很多个小问题或子过程，这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决。

举个典型的面向过程的例子， 数据库备份， 分三步，连接数据库，备份数据库，测试备份文件可用性。
代码如下

```
def db_conn():
    print("connecting db...")


def db_backup(dbname):
    print("导出数据库...",dbname)
    print("将备份文件打包，移至相应目录...")

def db_backup_test():
    print("将备份文件导入测试库，看导入是否成功")


def main():
    db_conn()
    db_backup('my_db')
    db_backup_test()



if __name__ == '__main__':
    main()
```

这样做的问题也是显而易见的，就是如果你要对程序进行修改，对你修改的那部分有依赖的各个部分你都也要跟着修改， 举个例子，如果程序开头你设置了一个变量值 为1 ， 但如果其它子过程依赖这个值 为1的变量才能正常运行，那如果你改了这个变量，那这个子过程你也要修改，假如又有一个其它子程序依赖这个子过程 ， 那就会发生一连串的影响，随着程序越来越大， 这种编程方式的维护难度会越来越高。
所以我们一般认为， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程的方式是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护 的， 那还是用面向对象最方便了。

##面向对象编程

OOP编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述，使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。

##面向对象的几个核心特性如下

###Class 类
一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法

###Object 对象
一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同

###Encapsulation 封装
在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法

###Inheritance 继承
一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承

###Polymorphism 多态
多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。
编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。
对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。
多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定

#面向对象编程(Object-Oriented Programming )介绍
对于编程语言的初学者来讲，OOP不是一个很容易理解的编程方式，大家虽然都按老师讲的都知道OOP的三大特性是继承、封装、多态，并且大家也都知道了如何定义类、方法等面向对象的常用语法，但是一到真正写程序的时候，还是很多人喜欢用函数式编程来写代码，特别是初学者，很容易陷入一个窘境就是“我知道面向对象，我也会写类，但我依然没发现在使用了面向对象后，对我们的程序开发效率或其它方面带来什么好处，因为我使用函数编程就可以减少重复代码并做到程序可扩展了，为啥子还用面向对象？”。 对于此，我个人觉得原因应该还是因为你没有充分了解到面向对象能带来的好处，今天我就写一篇关于面向对象的入门文章，希望能帮大家更好的理解和使用面向对象编程。  

无论用什么形式来编程，我们都要明确记住以下原则：
写重复代码是非常不好的低级行为
你写的代码需要经常变更

开发正规的程序跟那种写个运行一次就扔了的小脚本一个很大不同就是，你的代码总是需要不断的更改，不是修改bug就是添加新功能等，所以为了日后方便程序的修改及扩展，你写的代码一定要遵循易读、易改的原则（专业数据叫可读性好、易扩展）。

如果你把一段同样的代码复制、粘贴到了程序的多个地方以实现在程序的各个地方调用 这个功能，那日后你再对这个功能进行修改时，就需要把程序里多个地方都改一遍，这种写程序的方式是有问题的，因为如果你不小心漏掉了一个地方没改，那可能会导致整个程序的运行都 出问题。 因此我们知道 在开发中一定要努力避免写重复的代码，否则就相当于给自己再挖坑。

还好，函数的出现就能帮我们轻松的解决重复代码的问题，对于需要重复调用的功能，只需要把它写成一个函数，然后在程序的各个地方直接调用这个函数名就好了，并且当需要修改这个功能时，只需改函数代码，然后整个程序就都更新了。

其实OOP编程的主要作用也是使你的代码修改和扩展变的更容易，那么小白要问了，既然函数都能实现这个需求了，还要OOP干毛线用呢？ 呵呵，说这话就像，古时候，人们打仗杀人都用刀，后来出来了枪，它的主要功能跟刀一样，也是杀人，然后小白就问，既然刀能杀人了，那还要枪干毛线，哈哈，显而易见，因为枪能更好更快更容易的杀人。函数编程与OOP的主要区别就是OOP可以使程序更加容易扩展和易更改。

小白说，我读书少，你别骗我，口说无凭，证明一下，好吧，那我们就下面的例子证明给小白看。
相信大家都打过CS游戏吧，我们就自己开发一个简单版的CS来玩一玩。





##类的语法
```
class Dog(object):

    print("hello,I am a dog!")


d = Dog() #实例化这个类，
#此时的d就是类Dog的实例化对象

#实例化，其实就是以Dog类为模版，在内存里开辟一块空间，存上数据，赋值成一个变量名
```

上面的代码其实有问题，想给狗起名字传不进去。

```
class Dog(object):

    def __init__(self,name,dog_type):
        self.name = name
        self.type = dog_type

    def sayhi(self):

        print("hello,I am a dog, my name is ",self.name)


d = Dog('LiChuang',"京巴")
d.sayhi()
```
为什么有__init__? 为什么有self? 此时的你一脸蒙逼，相信不画个图，你的智商是理解不了的！　　

画图之前， 你先注释掉这两句

```
# d = Dog('LiChuang', "京巴")
# d.sayhi()

print(Dog)
```

没实例直接打印Dog输出如下
`<class '__main__.Dog'>`
其实self,就是实例本身！你实例化时python会自动把这个实例本身通过self参数传进去。
好了，明白 了类的基本定义，接下来我们一起分解一下上面的代码分别 是什么意思

```
class Role(object): #定义一个类， class是定义类的语法，Role是类名，(object)是新式类的写法，必须这样写，以后再讲为什么
    def __init__(self,name,role,weapon,life_value=100,money=15000): #初始化函数，在生成一个角色时要初始化的一些属性就填写在这里
        self.name = name #__init__中的第一个参数self,和这里的self都 是什么意思？ 看下面解释
        self.role = role
        self.weapon = weapon
        self.life_value = life_value
        self.money = money
```
上面的这个__init__()叫做初始化方法(或构造方法)， 在类被调用时，这个方法(虽然它是函数形式，但在类中就不叫函数了,叫方法)会自动执行，进行一些初始化的动作，所以我们这里写的__init__(self,name,role,weapon,life_value=100,money=15000)就是要在创建一个角色时给它设置这些属性，那么这第一个参数self是干毛用的呢？

初始化一个角色，就需要调用这个类一次：
```
r1 = Role('Alex','police','AK47’) #生成一个角色 , 会自动把参数传给Role下面的__init__(...)方法
r2 = Role('Jack','terrorist','B22’)  #生成一个角色
```
我们看到，上面的创建角色时，我们并没有给__init__传值，程序也没未报错，是因为，类在调用它自己的__init__(…)时自己帮你给self参数赋值了，
```
r1 = Role('Alex','police','AK47’) #此时self 相当于 r1 ,  Role(r1,'Alex','police','AK47’)
r2 = Role('Jack','terrorist','B22’)#此时self 相当于 r2, Role(r2,'Jack','terrorist','B22’)
```

为什么这样子？你拉着我说你有些犹豫，怎么会这样子？
你执行r1 = Role('Alex','police','AK47’)时，python的解释器其实干了两件事：
在内存中开辟一块空间指向r1这个变量名
调用Role这个类并执行其中的__init__(…)方法，相当于Role.__init__(r1,'Alex','police',’AK47’),这么做是为什么呢？ 是为了把'Alex','police',’AK47’这3个值跟刚开辟的r1关联起来，是为了把'Alex','police',’AK47’这3个值跟刚开辟的r1关联起来，是为了把'Alex','police',’AK47’这3个值跟刚开辟的r1关联起来，重要的事情说3次， 因为关联起来后，你就可以直接r1.name, r1.weapon 这样来调用啦。所以，为实现这种关联，在调用__init__方法时，就必须把r1这个变量也传进去，否则__init__不知道要把那3个参数跟谁关联呀。
明白了么哥？所以这个__init__(…)方法里的，self.name = name , self.role = role 等等的意思就是要把这几个值 存到r1的内存空间里。
如果还不明白的话，哥，去测试一下智商吧， 应该不会超过70，哈哈。
为了暴露自己的智商，此时你假装懂了，但又问， __init__(…)我懂了，但后面的那几个函数，噢 不对，后面那几个方法 为什么也还需要self参数么？ 不是在初始化角色的时候 ，就已经把角色的属性跟r1绑定好了么？
good question, 先来看一下上面类中的一个buy_gun的方法：

```
def buy_gun(self,gun_name):
    print(“%s has just bought %s” %(self.name,gun_name) )
```
上面这个方法通过类调用的话要写成如下：
```
r1 = Role('Alex','police','AK47')
r1.buy_gun("B21”) #python 会自动帮你转成 Role.buy_gun(r1,”B21")
```

执行结果
`#Alex has just bought B21 `
依然没给self传值 ，但Python还是会自动的帮你把r1 赋值给self这个参数， 为什么呢？ 因为，你在buy_gun(..)方法中可能要访问r1的一些其它属性呀， 比如这里就访问 了r1的名字，怎么访问呢？你得告诉这个方法呀，于是就把r1传给了这个self参数，然后在buy_gun里调用 self.name 就相当于调用r1.name 啦，如果还想知道r1的生命值 有多少，直接写成self.life_value就可以了。 说白了就是在调用类中的一个方法时，你得告诉人家你是谁。

好啦， 总结一下2点：
1. 上面的这个r1 = Role('Alex','police','AK47’)动作，叫做类的“实例化”， 就是把一个虚拟的抽象的类，通过这个动作，变成了一个具体的对象了， 这个对象就叫做实例
1. 刚才定义的这个类体现了面向对象的第一个基本特性，封装，其实就是使用构造方法将内容封装到某个具体对象中，然后通过对象直接或者self间接获取被封装的内容

##面向对象的特性：
###封装

封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。

封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

###继承

面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”。

被继承的类称为“基类”、“父类”或“超类”。

继承的过程，就是从一般到特殊的过程。

要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式主要有2类：实现继承、接口继承。

Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；
Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力(子类重构爹类方法)；
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。

抽象类仅定义将由子类创建的一般属性和方法。
OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。

继承示例

```
class SchoolMember(object):
    members = 0 #初始学校人数为0
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def  tell(self):
        pass

    def enroll(self):
        '''注册'''
        SchoolMember.members +=1
        print("\033[32;1mnew member [%s] is enrolled,now there are [%s] members.\033[0m " %(self.name,SchoolMember.members))

    def __del__(self):
        '''析构方法'''
        print("\033[31;1mmember [%s] is dead!\033[0m" %self.name)
class Teacher(SchoolMember):
    def __init__(self,name,age,course,salary):
        super(Teacher,self).__init__(name,age)
        self.course = course
        self.salary = salary
        self.enroll()


    def teaching(self):
        '''讲课方法'''
        print("Teacher [%s] is teaching [%s] for class [%s]" %(self.name,self.course,'s12'))

    def tell(self):
        '''自我介绍方法'''
        msg = '''Hi, my name is [%s], works for [%s] as a [%s] teacher !''' %(self.name,'Oldboy', self.course)
        print(msg)

class Student(SchoolMember):
    def __init__(self, name,age,grade,sid):
        super(Student,self).__init__(name,age)
        self.grade = grade
        self.sid = sid
        self.enroll()


    def tell(self):
        '''自我介绍方法'''
        msg = '''Hi, my name is [%s], I'm studying [%s] in [%s]!''' %(self.name, self.grade,'Oldboy')
        print(msg)

if __name__ == '__main__':
    t1 = Teacher("Alex",22,'Python',20000)
    t2 = Teacher("TengLan",29,'Linux',3000)

    s1 = Student("Qinghua", 24,"Python S12",1483)
    s2 = Student("SanJiang", 26,"Python S12",1484)

    t1.teaching()
    t2.teaching()
    t1.tell()
```
###多态


多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

Pyhon 很多语法都是支持多态的，比如 len(),sorted(), 你给len传字符串就返回字符串的长度，传列表就返回列表长度。

Python多态示例
```
#_*_coding:utf-8_*_


class Animal(object):
    def __init__(self, name):  # Constructor of the class
        self.name = name

    def talk(self):              # Abstract method, defined by convention only
        raise NotImplementedError("Subclass must implement abstract method")


class Cat(Animal):
    def talk(self):
        print('%s: 喵喵喵!' %self.name)


class Dog(Animal):
    def talk(self):
        print('%s: 汪！汪！汪！' %self.name)



def func(obj): #一个接口，多种形态
    obj.talk()

c1 = Cat('小晴')
d1 = Dog('李磊')

func(c1)
func(d1)
```

##领域模型

好了，你现在会了面向对象的各种语法了， 那请看下本章最后的作业需求，我相信你可能是蒙蔽的， 很多同学都是学会了面向对象的语法，却依然写不出面向对象的程序，原因是什么呢？原因就是因为你还没掌握一门面向对象设计利器， 你说我读书少别骗我， 什么利器？

答案就是:领域建模。 从领域模型开始,我们就开始了面向对象的分析和设计过程,可以说,领域模型是完成从需求分析到面向 对象设计的一座桥梁。



领域模型,顾名思义,就是需求所涉及的领域的一个建模,更通俗的讲法是业务模型。 参考百度百科(http://baike.baidu.cn/view/757895.htm ),领域模型定义如下:

从这个定义我们可以看出,领域模型有两个主要的作用:

发掘重要的业务领域概念
建立业务领域概念之间的关系

##领域建模三字经

领域模型如此重要,很多同学可能会认为领域建模很复杂,需要很高的技巧。然而事实上领域建模非常简 单,简单得有点难以让人相信,领域建模的方法概括一下就是“找名词”! 许多同学看到这个方法后估计都会笑出来:太假了吧,这么简单,找个初中生都会啊,那我们公司那些分 析师和设计师还有什么用哦?

分析师和设计师当然有用,后面我们会看到,即使是简单的找名词这样的操作,也涉及到分析和提炼,而 不是简单的摘取出来就可,这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析 也确实相对简单,即使没有丰富的经验和高超的技巧,至少也能完成一个能用的领域模型。

虽然我们说“找名词”很简单,但一个关键的问题还没有说明:从哪里找? 如果你还记得领域模型是“需求到面向对象的桥梁”,那么你肯定一下子就能想到:从需求模型中找,具 体来说就是从用例中找。

归纳一下域建模的方法就是“从用例中找名词”。 当然,找到名词后,为了能够更加符合面向对象的要求和特点,我们还需要对这些名词进一步完善,这就 是接下来的步骤:加属性,连关系!

最后我们总结出领域建模的三字经方法:找名词、加属性、连关系。

找名词

who : 学员、讲师、管理员

用例：

1. 管理员 创建了 北京 和 上海 两个校区

2. 管理员 创建了 Linux \ Python \ Go 3个课程

3. 管理员 创建了 北京校区的Python 16期， Go开发第一期，和上海校区的Linux 36期 班级

4. 管理员 创建了 北京校区的 学员 小晴 ，并将其 分配 在了 班级  python 16期

5. 管理员 创建了 讲师 Alex , 并将其分配 给了 班级 python 16期 和全栈脱产5期

6. 讲师 Alex 创建 了一条 python 16期的 上课纪录 Day6

7. 讲师 Alex 为Day6这节课 所有的学员 批了作业 ，小晴得了A, 李磊得了C-, 严帅得了B

8. 学员小晴 在 python 16 的 day6里 提交了作业

9. 学员李磊 查看了自己所报的所有课程

10. 学员 李磊  在 查看了 自己在 py16期 的 成绩列表 ，然后自杀了

11. 学员小晴  跟 讲师 Alex 表白了

名词列表：

管理员、校区、课程、班级、上课纪录、作业、成绩、讲师、学员

加属性

连关系

有了类,也有了属性,接下来自然就是找出它们的关系了。
